# Модель Live-трансляции на платформе Twitch

## 1. Введение
Согласно варианту задания, необходимо разработать имитационную модель процесса передачи live-стрима на платформе Twitch. <br> Основной акцент делается на нелинейной динамике системы: зависимости качества восприятия (аудио/видео синхронизация, рывки) от состояния сети и настроек буферизации.

Модель включает следующие функциональные блоки: 
- **Генерация контента (Стример)**,
- **Кодирование/Отправка**,
- **Сетевой канал доставки (CDN/Интернет)**,
- **Клиентский буфер (Плеер зрителя)**,
- **Декодирование и Воспроизведение (Зритель)**.

## 2. Законы моделирования внутри блоков:
### 1. Блок «Генерация контента (Стример)»

**Назначение:** Создание эталонного потока несжатых аудио и видеоданных, идеально синхронизированных между собой.

- **Входные данные:** Отсутствуют (внутренний источник).
    
- **Выходные данные:** Последовательность кадров видео и блоков аудио с присвоенными метками времени (PTS – Presentation Time Stamp), отсчитываемыми от начала стрима.
    
- **Законы функционирования:**
    
    - **Видеопоток:** Генерируется с постоянной частотой кадров _fps_ (например, 60 кадров/с). Интервал между соседними кадрами детерминирован: *T_v = 1/fps*. Вместо настоящего видеопотока, генерируются числа, которые характеризуют динамичность сцены в видео: чем динамичнее сцена, тем больше разница между числами.
        
    - **Аудиопоток:** Генерируется непрерывно с заданной частотой дискретизации (например, 48 кГц). Для целей моделирования аудио разбивается на блоки фиксированной длительности (например, 20 мс), которые и будут обрабатываться кодером. Каждый блок также получает метку времени. Вместо настоящего аудио-потока генерируется поток чисел в диапозоне, характеризующий громкость аудио.
        
    - **Синхронизация на входе:** Метки времени видео- и аудиоблоков, соответствующие одному моменту реального времени, совпадают. Это идеальное состояние, которое в реальности достигается аппаратной синхронизацией.
        

### 2. Блок «Кодирование и отправка»

**Назначение:** Преобразование несжатых данных в транспортные пакеты, готовые к передаче по сети. Здесь возникает первая существенная неравномерность потока.

- **Входные данные:** Несжатые кадры видео и блоки аудио с метками времени.
    
- **Выходные данные:** Поток сетевых пакетов, каждый из которых содержит фрагмент сжатых данных, его метку времени, тип (аудио/видео) и размер в байтах. Пакеты отправляются в сеть немедленно после формирования (моделируется протокол реального времени, например, RTMP).
    
- **Законы функционирования:**
    
    1. **Кодирование видео:** Используется переменный битрейт (VBR). Размер сжатого кадра _S_v_ (в байтах) и время кодирования _τ_enc_ зависят от типа кадра и сложности сцены.
        
        - **Типы кадров:** Ключевые кадры (I-кадры) обычно имеют значительно больший размер, чем кадры-предсказания (P/B-кадры). Интервал между I-кадрами (_GOP size_) задаётся параметром модели.
            
        - **Распределение размера кадра:** Для I-кадров используется **распределение Парето** (или логнормальное), которое хорошо описывает редкие, но очень большие значения (тяжёлый хвост). Это отражает ситуацию, когда сцена резко меняется, и I-кадр содержит много новой информации. Для P/B-кадров, размер которых меняется плавно, можно использовать **нормальное распределение** со средним, зависящим от предыдущего кадра.
            
        - **Время кодирования:** В первом приближении _τ_enc_ пропорционально размеру кадра _S_v_ плюс независимая случайная составляющая, отражающая вариации загрузки процессора. Эту составляющую можно моделировать **нормальным распределением** с малым коэффициентом вариации.
            
    2. **Кодирование аудио:** Аудио кодируется с постоянным битрейтом (CBR), поэтому размер каждого аудио-пакета _S_a_ постоянен. Время кодирования аудио пренебрежимо мало и считается константой.
        
    3. **Формирование сетевых пакетов:** Сжатый кадр видео может быть больше максимального размера пакета (MTU), поэтому он фрагментируется на несколько пакетов. Эти пакеты отправляются в сеть последовательно с минимальными интервалами, создавая **пачку (burst)**. Аудио-пакеты, как правило, помещаются в один пакет и отправляются с постоянным интервалом _T_a_.
        
### 3. Блок «Сетевой канал доставки »

**Назначение:** Транспортировка пакетов от стримера к зрителю с внесением искажений: задержек, джиттера и потерь.

- **Входные данные:** Поток пакетов с моментами отправки _t_send[i]_, размерами _size[i]_ и типом.
    
- **Выходные данные:** Поток тех же пакетов (за исключением потерянных) с новыми моментами получения _t_recv[i]_.
    
- **Законы функционирования:**  
    Модель сети представляется как одноканальная система массового обслуживания (M/M/1/K или более сложная) с очередью.
    
    - **Пропускная способность:** Канал имеет ограниченную пропускную способность _C_ (бит/с). Время обслуживания пакета (передачи в канал) составляет _τ_tx[i] = size[i] / C_.
        
    - **Очередь:** На входе канала имеется буфер (очередь) максимального размера _K_ пакетов (или байтов). Пакеты, поступающие в момент, когда буфер полностью занят, **теряются**.
        
    - **Задержка в очереди:** Время ожидания пакета в очереди _τ_queue[i]_ зависит от текущей загрузки буфера. Эта задержка нелинейно растёт с увеличением интенсивности входного потока и может быть рассчитана по мере обслуживания пакетов в порядке очереди (FIFO).
        
    - **Задержка распространения:** Константа _d_prop_, соответствующая времени прохождения сигнала по физической среде (пинг).
        
    - **Джиттер:** Реальная задержка доставки _τ_net[i]_ складывается из времени ожидания в очереди, времени передачи и задержки распространения. Вариация _τ_queue[i]_ создаёт джиттер. Для моделирования дополнительных случайных флуктуаций (например, перемаршрутизации) можно добавить случайную составляющую, распределённую по **экспоненциальному закону**, что отражает наличие «тяжёлого хвоста» в распределении задержек (большинство пакетов идут быстро, но некоторые застревают надолго).
        
    - **Потери пакетов:** Потери возникают либо при переполнении буфера (основной механизм), либо как редкие случайные события (например, из-за помех на линии). Случайные потери моделируются **пуассоновским потоком событий** с заданной интенсивностью. При моделировании каждого пакета с вероятностью *p* он может быть «уничтожен» независимо от других.

### 4. Блок «Клиентский буфер (Плеер зрителя)»

**Назначение:** Сглаживание джиттера и обеспечение непрерывного воспроизведения. Именно здесь принимаются решения, влияющие на QoE.

- **Входные данные:** Поток пакетов, пришедших из сети, с временами получения _t_recv[i]_, метками времени _pts[i]_, типом и размером.
    
- **Выходные данные:** Сигналы на воспроизведение аудио и видео кадров, а также статистические показатели: текущий уровень заполнения буфера, моменты начала рывков (underflow), величина рассинхронизации.
    
- **Законы функционирования:**
    
    1. **Приём и сортировка:** Все приходящие пакеты помещаются в буфер, который организован как очередь с приоритетом по метке времени _pts_. Это необходимо, так как пакеты могут прийти не по порядку.
        
    2. **Воспроизведение видео:** Плеер имеет внутренние часы, которые в нормальном состоянии тикают с интервалом _T_v_. Перед каждым тиком плеер проверяет, есть ли в буфере видеокадр с меткой времени, равной текущему времени воспроизведения (или ближайшей будущей). Если такой кадр есть, он извлекается из буфера и отправляется на декодер (считаем мгновенным), а часы увеличиваются на _T_v_.
        
        - **Условие рывка (underflow):** Если в буфере нет видеоданных для текущего момента времени (буфер пуст), воспроизведение останавливается. Часы плеера замирают. Начинается событие «рывок». Рывок продолжается до тех пор, пока буфер не накопит достаточное количество данных. Обычно используется порог _B_min_ (например, 1 секунда) для возобновления воспроизведения.
            
        - **Заполнение буфера:** Уровень буфера _L(t)_ (в секундах контента) вычисляется как разность между меткой времени самого «свежего» пакета в буфере и текущим временем воспроизведения. _L(t)_ динамически меняется: растёт при поступлении пакетов (со скоростью входного потока) и убывает при воспроизведении (с постоянной скоростью).
            
    3. **Воспроизведение аудио:** Аналогично видео, аудио извлекается из своего буфера (физически буфер общий, но логически разделён по типу). Аудио критично к своевременности: даже кратковременная нехватка данных приводит к щелчку или выпадению.
        
    4. **Синхронизация аудио и видео (A/V sync):** Плеер непрерывно сравнивает метки времени аудио- и видеокадров, которые должны быть воспроизведены в данный момент. Пусть _pts_audio_ и _pts_video_ – метки ближайших к воспроизведению кадров. Разность _Δ = pts_audio – pts_video_ показывает рассогласование. Если |_Δ_| превышает допустимый порог _Δ_th_ (например, 40 мс), система констатирует рассинхронизацию.
        
        - **Механизм коррекции:** Модель может реализовать один из методов:
            
            - **Повтор/пропуск кадров:** Если видео отстаёт (pts_video < pts_audio), можно временно воспроизводить видео быстрее (пропуская отдельные кадры), чтобы догнать аудио. Если видео опережает – показывать некоторые кадры дважды.
                
            - **Сброс синхронизации:** В критическом случае (например, при длительной рассинхронизации более 500 мс) плеер может сбросить буфер и начать воспроизведение заново с ближайшей синхронной пары (часто это происходит на ключевом кадре). Это худший сценарий для зрителя, так как приводит к длительному рывку.

### 5. Блок «Декодирование и вывод (Зритель)»

**Назначение:** Преобразование сжатых кадров в сигналы для отображения и звуковоспроизведения. В контексте модели этот блок часто считается идеальным, так как современные декодеры работают быстрее реального времени.

- **Входные данные:** Кадры видео и блоки аудио, извлечённые из буфера плеера.
    
- **Выходные данные:** События вывода на экран и динамики (регистрируются в статистике).
    
- **Законы функционирования:**
    
    - Декодирование происходит мгновенно (задержка декодирования пренебрежимо мала по сравнению с сетевыми задержками).
        
    - Вывод происходит точно в момент, определённый логикой плеера. Если кадр выводится с опозданием, это считается рывком. Если аудио и видео выводятся с недопустимой разницей во времени, это фиксируется как рассинхронизация.

**Правила перехода между блоками:**
Передача информации осуществляется пакетами, имеющими метку времени (timestamp) и идентификатор потока (аудио/видео). Переход от стримера к сети происходит по мере готовности пакетов кодеком. Переход от сети к буферу — по мере получения пакетов с учетом сетевых задержек и потерь. Внутри плеера логика "планировщика" решает, какой пакет (аудио или видео) отправить на декодирование следующим, чтобы сохранить синхронизацию.

## 3. Описание системы

**Системные границы:**
*   **Входная информация:** Характеристики исходного потока (битрейт видео, частота кадров, частота дискретизации аудио), параметры сети (пропускная способность, задержка, вероятность потерь), параметры плеера (размер буфера).
*   **Выходная информация:** Качество восприятия на стороне зрителя (QoE): количество и длительность рывков, величина рассинхронизации аудио и видео (в мс), время до начала проигрывания (буферизация при старте).
*   **Границы применимости:** Модель включает влияние вариаций сетевой задержки (джиттер) и потерь пакетов на буфер плеера. Исключаются из модели: аппаратное аппаратная часть стримера (температура процессора), социальное взаимодействие (чат), задержка стримера, системы рекомендаций, наложения объектов стримером (вебка, спонсорские плашки).

## 4. Используемые распределения

Для адекватного моделирования нестабильностей используются следующие стохастические распределения:
1. **Распределение времени кодирования видео: Нормальное (Гауссово).**
    
    - _Обоснование:_ Хотя в реальности кодирование детерминировано железом, в условиях переменной сложности сцены время обработки кадра колеблется вокруг среднего значения. Нормальное распределение хорошо подходит для моделирования таких естественных вариаций, так как большинство кадров будут кодироваться со средним временем, и лишь немногие (сложные сцены) потребуют чуть больше времени.
        
2. **Распределение времени задержки в сети (Джиттер): Экспоненциальное или Логнормальное.**
    
    - _Обоснование:_ В сетях передачи данных задержки часто асимметричны. Большинство пакетов приходят с минимальной задержкой (близкой к пингу), но существует "тяжелый хвост" — небольшое количество пакетов, которые задерживаются надолго из-за перегрузок на маршрутизаторах. Экспоненциальное распределение хорошо моделирует это явление: высокая вероятность малой задержки и быстро убывающая, но ненулевая вероятность большой задержки.
        
3. **Распределение потерь пакетов: Пуассоновское (для потока событий).**
    
    - _Обоснование:_ Потерю пакетов можно рассматривать как редкие события. Использование пуассоновского потока для генерации моментов потерь позволяет моделировать случайные всплески (спайки) потерь, которые критичны для аудио: потеря нескольких пакетов подряд приводит к отчетливому "хрипу" или выпадению звука.

## 5. Параметры модели

1.  **Параметры стримера:**
    *   `video_bitrate`: Средний битрейт видео (например, 4500 Кбит/с для качества 1080p). Данные берутся из рекомендаций платформы Twitch.
    *   `fps`: Частота кадров (60 или 30). Стандарт для стримов.
    *   `gop_size`: Интервал между ключевыми кадрами (например, 2 секунды). От этого зависит размер пачек трафика.
    *   `audio_bitrate`: Битрейт аудио (например, 160 Кбит/с).
2.  **Параметры сети:**
    *   `bandwidth`: Доступная пропускная способность канала до зрителя (Кбит/с). Гипотетические данные или результаты тестов скорости.
    *   `network_delay`: Базовая задержка (пинг), например 20 мс.
    *   `jitter_intensity`: Интенсивность джиттера (стандартное отклонение задержки).
    *   `packet_loss_probability`: Вероятность потери пакета (например, 0.1% - 1%). Данные берутся из статистики качества интернет-соединений.
3.  **Параметры плеера:**
    *   `initial_buffer_duration`: Время накопления буфера перед стартом (например, 2 секунды). Параметр настройки плеера.
    *   `max_buffer_size`: Максимальный размер буфера в секундах (например, 10 секунд).
    *   `av_sync_threshold`: Порог рассинхронизации в мс (например, 40 мс).
